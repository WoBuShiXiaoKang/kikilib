#include "EventManager.h"
#include "LogManager.h"
#include "EventService.h"
#include "TimerEventService.h"
#include "Timer.h"
#include "ThreadPool.h"

#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <signal.h>

using namespace kikilib;

EventManager::EventManager(int idx) : _idx(idx), _quit(false), _pLooper(nullptr), _pTimer(nullptr)
{ }

EventManager::~EventManager()
{
	_quit = true;
	for (auto pEvServ : _eventSet)
	{
		delete pEvServ;
	}
	if (_pTimer)
	{
		delete _pTimer;
	}
	if (_pLooper)
	{
		_pLooper->join();
		delete _pLooper;
	}
}

void EventManager::Loop()
{
	//初始化定时器服务
	int timeFd = ::timerfd_create(CLOCK_MONOTONIC,
		TFD_NONBLOCK | TFD_CLOEXEC);
	if (timeFd < 0)
	{
		RecordLog(ERROR_DATA_INFORMATION,std::to_string(_idx) + " eventManager timer init failed!");
		return;
	}
	Socket timeSock(timeFd);
	_pTimer = new Timer(timeSock);
	EventService* pTimerServe = new TimerEventService(_pTimer, timeSock, this);
	//设置定时器事件为优先级最高的事件
	pTimerServe->SetEventPriority(IMMEDIATE_EVENT);

	Insert(pTimerServe);

	//初始化loop
	_pLooper = new std::thread(
		[this]
		{
			while (!this->_quit)
			{
				//清空所有列表
				if(this->_actEvServs.size())
                {
                    this->_actEvServs.clear();
                }
				for (int i = 0; i < EVENT_PRIORITY_TYPE_COUNT; ++i)
				{
				    if(this->_priorityEvQue[i].size())
                    {
                        this->_priorityEvQue[i].clear();
                    }
				}
				//获取活跃事件
				this->_epoller.GetActEvServ(Parameter::epollTimeOutMs, this->_actEvServs);
				//按优先级分队
				for (auto pEvServ : this->_actEvServs)
				{
					if (pEvServ->GetEventPriority() >= IMMEDIATE_EVENT)
					{
						(this->_priorityEvQue[IMMEDIATE_EVENT]).push_back(pEvServ);
					}
					else
					{
						(this->_priorityEvQue[NORMAL_EVENT]).push_back(pEvServ);
					}
				}
				//按照优先级处理事件
				for (int i = 0; i < EVENT_PRIORITY_TYPE_COUNT; ++i)
				{
					for (auto evServ : this->_priorityEvQue[i])
					{
						evServ->HandleEvent();
					}
				}
				//处理不再关注的事件
				for (auto unusedEv : this->_removedEv)
				{
					//从监听事件中移除
					this->_epoller.RemoveEv(unusedEv);
					//close这个fd
					delete unusedEv;
				}
				if(this->_removedEv.size())
                {
                    std::lock_guard<std::mutex> lock(_removedEvMutex);
                    this->_removedEv.clear();
                }
			}
		}
		);
}

//向事件管理器中插入一个事件
void EventManager::Insert(EventService* ev)
{
	if (!ev)
	{
		return;
	}
	{
		std::lock_guard<std::mutex> lock(_eventSetMutex);
		_eventSet.insert(ev);
	}
	_epoller.AddEv(ev);
}

//向事件管理器中移除一个事件
void EventManager::Remove(EventService* ev)
{
	if (!ev)
	{
		return;
	}
	//从映射表中删除事件
    std::lock_guard<std::mutex> lock(_eventSetMutex);
	auto it = _eventSet.find(ev);
	if (it != _eventSet.end())
	{
		_eventSet.erase(it);
	}
	//放入被移除事件列表
	_removedEv.push_back(ev);
}

//向事件管理器中修改一个事件服务所关注的事件类型
void EventManager::Motify(EventService* ev)
{
	if (!ev)
	{
		return;
	}

	{
		std::lock_guard<std::mutex> lock(_eventSetMutex);
		if (_eventSet.find(ev) == _eventSet.end())
		{
			Insert(ev);
			return;
		}
	}
	_epoller.MotifyEv(ev);
}

//time时间后执行timerCb函数
void EventManager::RunAfter(Time time, std::function<void()> timerCb)
{
	Time runTime(Time::now().GetTimeVal() + time.GetTimeVal());

	_pTimer->RunAt(runTime, timerCb);
}

//time时间后执行timerCb函数
void EventManager::RunEvery(Time time, std::function<void()> timerCb)
{
	std::function<void()> realTimerCb(
		[this, time, timerCb]
		{
			timerCb();
			this->RunEvery(time, timerCb);
		}
		);

	RunAfter(time, realTimerCb);

}

//将任务放在线程池中以达到异步执行的效果
template<class F, class... Args>
auto EventManager::RunInThreadPool(F&& f, Args&&... args)
->std::future<typename std::result_of<F(Args...)>::type>
{
    return _pThreadPool->enqueue(f,args...);
}
